---
title: "TITLE: Same Data, Different Story: An SEM Path Sensitivity Test (simulation & application)"
author: "-----"
date: "2025-10-31"
toc: TRUE
output: pdf_document
---

```{r setup, include=FALSE}

#### Global options ####

global_n_val <- c(100, 250, 500)
global_path_val <- seq(0.0, 0.5, 0.1)
global_nreps <- 5 ##500 to redo paper results 

#### Libraries ####

install.packages("mvpt", repos = NULL, type = "source")
library(mvpt)
library(lavaan)
library(lavaan)             
library(ggplot2)
library(scales)         


#### Application data ####

load("DATA/burnout.rda")

```


# SIMULATION STUDIES

## Simulation 1a: Confounder

```{r sim1a, echo=FALSE, warning=FALSE}

#### Simulation 1a: Confounder ####

Model1 <- "Y ~ a*X"  
Model2 <- "Y ~ a*X + c*Z"

confoundertest <- function(n_val, b_val, c_val) {
  ## Simulate data given "b" and "c" path values, everything else at 1.00
  DAG <- paste("
               X ~  ", b_val, "*Z
               Y ~  (1.00)*X + ", c_val, "*Z
               X ~~ (1.00)*X
               Y ~~ (1.00)*Y
               ")
  SIMU <- simulateData(model=DAG, sample.nobs=n_val) 
  ## Model1 and Model2 fitted to SIMU
  Model1.fit <- sem(model=Model1, data=SIMU)
  Model2.fit <- sem(model=Model2, data=SIMU)
  ## MVP test on "a"
  mvpt(list(Model1.fit, Model2.fit), "a")$p.val
}

## Looping test under multiple conditions, and getting mean(p_val<0.5) across nreps
n_val <- global_n_val 
b_val <- global_path_val
c_val <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(b_val)) {
    for(j in 1:length(c_val)) {
      for(k in 1:nreps) { 
        p_val[k] <- confoundertest(n_val[h], b_val[i], c_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], b_val[i], c_val[j], mean(p_val<.05)))
    }
  }
}
PATHS1a <- data.frame(PATHS)
colnames(PATHS1a) <- c("n_val", "b_val", "c_val", "power")
PATHS1a$n_val <- factor(PATHS1a$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS1a$b_val <- factor(PATHS1a$b_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS1a, aes(x=c_val, y=power, color=b_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=b_val)) +
    labs(x=expression(italic("c")), y="Power", color=expression(italic("b")), shape=expression(italic("b"))) +
    scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 1b: Mediator

```{r sim1b, echo=FALSE}

#### Simulation 1b: Mediator ####

Model1 <-
  '
Y ~ a*X  
'
Model2 <-
  '
Y ~ a*X + c*Z
'

mediatortest <- function(n_val, b_val, c_val) {
  ## Simulate data given "b" and "c" path values, everything else at 1.00
  DAG <- paste("
               Y ~  (1.00)*X + ", c_val, "*Z
               Z ~  ", b_val, "*X 
               Y ~~ (1.00)*Y
               Z ~~ (1.00)*Z
               ")
  SIMU <- simulateData(model=DAG, sample.nobs=n_val) 
  ## Model1 and Model2 fitted to SIMU
  Model1.fit <- sem(model=Model1, data=SIMU)
  Model2.fit <- sem(model=Model2, data=SIMU)
  ## MVP test on "a"
  mvpt(list(Model1.fit, Model2.fit), "a")$p.val
}

## Looping test under multiple conditions, and getting mean(p_val<0.5) across nreps
n_val <- global_n_val 
b_val <- global_path_val
c_val <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(b_val)) {
    for(j in 1:length(c_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- mediatortest(n_val[h], b_val[i], c_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], b_val[i], c_val[j], mean(p_val<.05)))
    }
  }
}
PATHS1b <- data.frame(PATHS)
colnames(PATHS1b) <- c("n_val", "b_val", "c_val", "power")
PATHS1b$n_val <- factor(PATHS1b$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS1b$b_val <- factor(PATHS1b$b_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS1b, aes(x=c_val, y=power, color=b_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=b_val)) +
    labs(x=expression(italic("c")), y="Power", color=expression(italic("b")), shape=expression(italic("b"))) +
    scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 1c: Collider

```{r sim1c, echo=FALSE}

#### Simulation 1c: Collider ####

Model1 <-
  '
Y ~ a*X  
'
Model2 <-
  '
Y ~ a*X + c*Z
'

collidertest <- function(n_val, b_val, c_val) {
  ## Simulate data given "b" and "c" path values, everything else at 1.00
  DAG <- paste("
               Y ~  (1.00)*X
               Z ~  ", b_val, "*X + ", c_val, "*Y
               Y ~~ (1.00)*Y
               Z ~~ (1.00)*Z
               ")
  SIMU <- simulateData(model=DAG, sample.nobs=n_val) 
  ## Model1 and Model2 fitted to SIMU
  Model1.fit <- sem(model=Model1, data=SIMU)
  Model2.fit <- sem(model=Model2, data=SIMU)
  ## MVP test on "a"
  mvpt(list(Model1.fit, Model2.fit), "a")$p.val
}

## Looping test under multiple conditions, and getting mean(p_val<0.5) across nreps
n_val <- global_n_val 
b_val <- global_path_val
c_val <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(b_val)) {
    for(j in 1:length(c_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- collidertest(n_val[h], b_val[i], c_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], b_val[i], c_val[j], mean(p_val<.05)))
    }
  }
}
PATHS1c <- data.frame(PATHS)
colnames(PATHS1c) <- c("n_val", "b_val", "c_val", "power")
PATHS1c$n_val <- factor(PATHS1c$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS1c$b_val <- factor(PATHS1c$b_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS1c, aes(x=c_val, y=power, color=b_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=b_val)) +
    labs(x=expression(italic("c")), y="Power", color=expression(italic("b")), shape=expression(italic("b"))) +
    scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 2a: Backdoor confounder

```{r sim2a_p1, echo=FALSE}

#### Simulation 2a: Backdoor confounder ####

Model1 <- 
  '
Y ~ a*X
'
Model2 <-
  '
Y ~ a*X + u*Z1
'
Model3 <-
  '
Y ~ a*X + c*Z2
'
Model4 <-  
  '
Y  ~ a*X + d*Z2 + e*Z1
'

Model5 <-  ## correctly specified model 
  '
Y  ~ a*X + d*Z2  
X  ~ b*Z1
Z2 ~ c*Z1
'

backdoortest <- function(model_list, n_val, bc_val, d_val) {
  ## Simulate data from an underlying DAG by using given n and path values
  DAG <- paste("
               Y  ~  (1.00)*X + ", d_val, "*Z2
               Z2 ~  ", bc_val, "*Z1
               X  ~  ", bc_val, "*Z1
               Y  ~~ (1.00)*Y
               Z2  ~~ (1.00)*Z2
               X  ~~ (1.00)*X
               ")
  SIMU <- simulateData(model=DAG, sample.nobs=n_val) 
  ## Each model from list fitted to SIMU
  fitted_list <- list()
  for (i in 1:length(model_list)) {
    fitted_list[[i]] <- sem(model=model_list[[i]], data=SIMU)
  }
  ## MVP test on shared "a" path estimate 
  mvpt(fitted_list, "a")$p.val
}

## Looping test under multiple conditions, and getting mean(p_val<0.5) across nreps
model_list <- list(Model1, Model2, Model3, Model4, Model5)
n_val <- global_n_val 
bc_val <- global_path_val
d_val  <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(bc_val)) {
    for(j in 1:length(d_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- backdoortest(model_list, n_val[h], bc_val[i], d_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], bc_val[i], d_val[j], mean(p_val<.05)))
    }
  }
}
PATHS2a <- data.frame(PATHS)
colnames(PATHS2a) <- c("n_val", "bc_val", "d_val", "power")
PATHS2a$n_val <- factor(PATHS2a$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS2a$bc_val <- factor(PATHS2a$bc_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS2a, aes(x=d_val, y=power, color=bc_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=bc_val)) +
    labs(x=expression(italic("d")), y="Power", color=expression(italic("b = c")), shape=expression(italic("b = c"))) +
    scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 2a: Backdoor confounder (correct models only)

```{r sim2a_p2, echo=FALSE}

## Re-looping test using correct models only
model_list <- list(Model2, Model3, Model4, Model5)
n_val <- global_n_val  
bc_val <- global_path_val
d_val <-  global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(bc_val)) {
    for(j in 1:length(d_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- backdoortest(model_list, n_val[h], bc_val[i], d_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], bc_val[i], d_val[j], mean(p_val<.05)))
    }
  }
}
PATHS2a.valid <- data.frame(PATHS)
colnames(PATHS2a.valid) <- c("n_val", "bc_val", "d_val", "power")
PATHS2a.valid$n_val <- factor(PATHS2a.valid$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS2a.valid$bc_val <- factor(PATHS2a.valid$bc_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS2a.valid, aes(x=d_val, y=power, color=bc_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=bc_val)) +
    labs(x=expression(italic("d")), y="Power", color=expression(italic("b = c")), shape=expression(italic("b = c"))) +
    ylim(0,1) +
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 2b: Confounder-mediator

```{r sim2b_p1, echo=FALSE}

#### Simulation 2b: Mediator-confounder ####

Model1 <-
  '
Y ~ a*X
'

Model2 <-
  '
Y ~ a*X + c*Z1
'
Model3 <-
  '
Y ~ a*X + e*Z2
'
Model4 <-
  '
Y ~ a*X + c*Z1 + e*Z2
'

Model5 <- ## correctly specified model
  '
Y  ~ a*X + c*Z1 + e*Z2  
X  ~ b*Z1
Z2 ~ d*X
'

conmeditest <- function(model_list, n_val, bc_val, de_val) {
  ## Simulate data 
  DAG <- paste("
               Y  ~  (1.00)*X + ", bc_val, "*Z1 + ", de_val, "*Z2
               X  ~  ", bc_val, "*Z1
               Z2 ~  ", de_val, "*X
               Y  ~~ (1.00)*Y
               X  ~~ (1.00)*X
               Z2 ~~ (1.00)*Z2
               ")
  SIMU <- simulateData(model=DAG, sample.nobs=n_val) 
  ## Models fitted to SIMU
  fitted_list <- list()
  for (i in 1:length(model_list)) {
    fitted_list[[i]] <- sem(model=model_list[[i]], data=SIMU)
  }
  ## MVP test on "a"
  mvpt(fitted_list, "a")$p.val
}

## Looping test under multiple conditions, and getting mean(p_val<0.5) across nreps
model_list <- list(Model1, Model2, Model3, Model4, Model5)
n_val <- global_n_val 
bc_val <- global_path_val
de_val <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(bc_val)) {
    for(j in 1:length(de_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- conmeditest(model_list, n_val[h], bc_val[i], de_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], bc_val[i], de_val[j], mean(p_val<.05)))
    }
  }
}
PATHS2b <- data.frame(PATHS)
colnames(PATHS2b) <- c("n_val", "bc_val", "de_val", "power")
PATHS2b$n_val <- factor(PATHS2b$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS2b$bc_val <- factor(PATHS2b$bc_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS2b, aes(x=de_val, y=power, color=bc_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=bc_val)) +
    labs(x=expression(italic("d = e")), y="Power", color=expression(italic("b = c")), shape=expression(italic("b = c"))) +
    scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 2b: Confounder-mediator (correct models only)

```{r sim2b_p2, echo=FALSE}

## Re-looping test using correct models only
model_list <- list(Model4, Model5)
n_val <- global_n_val
bc_val <- global_path_val
de_val <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(bc_val)) {
    for(j in 1:length(de_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- conmeditest(model_list, n_val[h], bc_val[i], de_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], bc_val[i], de_val[j], mean(p_val<.05)))
    }
  }
}
PATHS2b.valid <- data.frame(PATHS)
colnames(PATHS2b.valid) <- c("n_val", "bc_val", "de_val", "power")
PATHS2b.valid$n_val <- factor(PATHS2b.valid$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS2b.valid$bc_val <- factor(PATHS2b.valid$bc_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS2b.valid, aes(x=de_val, y=power, color=bc_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=bc_val)) +
    labs(x=expression(italic("d = e")), y="Power", color=expression(italic("b = c")), shape=expression(italic("b = c"))) +
    ylim(0,1) +
    #scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 2c: Confounder-collider trap

```{r sim2c_p1, echo=FALSE}

#### Simulation 2c: Confounder-collider trap ####

Model1 <-
  '
Y ~ a*X
'
Model2 <-
  '
Y ~ a*X + Z2
'
Model3 <-
  '
Y ~ a*X + Z1 + Z2
'
Model4 <-
  '
Y ~ a*X + Z2 + Z3
'
Model5 <-  ## correctly specified model 
  '
Y  ~ a*X + c*Z2 + Z3  
X  ~ Z1 + b*Z2
Z1 ~ U1
Z2 ~ d*U1 + e*U2
Z3 ~ U2
'

Mtest <- function(model_list, n_val, bc_val, de_val) {
  ## Simulate data 
  DAG <- paste("
               Y  ~  (1.00)*X  + ", bc_val, "*Z2 + (1.00)*Z3
               X  ~  (1.00)*Z1 + ", bc_val, "*Z2
               Z1 ~  (1.00)*U1
               Z2 ~  ", de_val, "*U1 + ", de_val, "*U2
               Z3 ~  (1.00)*U2 
               Y  ~~ (1.00)*Y
               X  ~~ (1.00)*X
               Z1 ~~ (1.00)*Z1
               Z2 ~~ (1.00)*Z2
               Z3 ~~ (1.00)*Z3
               ")
  SIMU <- simulateData(model=DAG, sample.nobs=n_val) 
  ## Models fitted to SIMU
  fitted_list <- list()
  for (i in 1:length(model_list)) {
    fitted_list[[i]] <- sem(model=model_list[[i]], data=SIMU)
  }
  ## MVP test on "a"
  mvpt(fitted_list, "a")$p.val
}

## Looping test under multiple conditions, and getting mean(p_val<0.5) across nreps
model_list <- list(Model1, Model2, Model3, Model4, Model5)
n_val <- global_n_val 
bc_val <- global_path_val
de_val <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(bc_val)) {
    for(j in 1:length(de_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- Mtest(model_list, n_val[h], bc_val[i], de_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], bc_val[i], de_val[j], mean(p_val<.05)))
    }
  }
}
PATHS2c <- data.frame(PATHS)
colnames(PATHS2c) <- c("n_val", "bc_val", "de_val", "power")
PATHS2c$n_val <- factor(PATHS2c$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS2c$bc_val <- factor(PATHS2c$bc_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS2c, aes(x=de_val, y=power, color=bc_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=bc_val)) +
    labs(x=expression(italic("d = e")), y="Power", color=expression(italic("b = c")), shape=expression(italic("b = c"))) +
    scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


## Simulation 2c: Confounder-collider trap (correct models only)

```{r sim2c_p2, echo=FALSE}

## Re-looping test using correct models only
model_list <- list(Model3, Model4, Model5)
n_val <- global_n_val
bc_val <- global_path_val
de_val <- global_path_val
nreps <- global_nreps
p_val <- vector(length = nreps)
PATHS <- matrix(NA, nrow = 0, ncol = 4)
for (h in 1:length(n_val)) {
  for(i in 1:length(bc_val)) {
    for(j in 1:length(de_val)) {
      for(k in 1:nreps) {  
        p_val[k] <- Mtest(model_list, n_val[h], bc_val[i], de_val[j])
      }
      PATHS <- rbind(PATHS, c(n_val[h], bc_val[i], de_val[j], mean(p_val<.05)))
    }
  }
}
PATHS2c.valid <- data.frame(PATHS)
colnames(PATHS2c.valid) <- c("n_val", "bc_val", "de_val", "power")
PATHS2c.valid$n_val <- factor(PATHS2c.valid$n_val, label=c("n = 100", "n = 250", "n = 500"))
PATHS2c.valid$bc_val <- factor(PATHS2c.valid$bc_val, label=c("0.0", "0.1", "0.2", "0.3", "0.4", "0.5"))

## Using ggplot to make figures faceted by sample size
ggplot(PATHS2c.valid, aes(x=de_val, y=power, color=bc_val)) +
    geom_line(size=1) +
    geom_point(size=3, aes(shape=bc_val)) +
    labs(x=expression(italic("d = e")), y="Power", color=expression(italic("b = c")), shape=expression(italic("b = c"))) +
    ylim(0,1) +
    #scale_y_continuous(labels=percent, breaks = seq(0, 1, by = .25)) + 
    facet_wrap(~n_val) +
    scale_color_manual(values=c("lightskyblue1", "royalblue", "royalblue4", "purple4", "purple" ,"red")) +
    theme(text = element_text(size = 25),
          axis.text.x = element_text(angle = 45, hjust = 1, size=18),
          axis.text.y = element_text(angle = 0, size=18),
          panel.background = element_rect(fill = "white", size = 0.5, linetype = "solid"),
          panel.grid.major = element_line(size = 0.5, linetype = 'solid',  colour = "bisque"), 
          panel.border = element_rect(colour = "black", fill=NA, size=3),
          strip.text.x = element_text(size = 22, angle = 0)
          )

```


# APPLICATION

## Part 1: Three competing models fit to the same workburnout dataset (standardized)

```{r application_p1, echo=FALSE}

Model1 <- 
"
    # regression
    PA ~ RA + DP + EE + SE + ELC
    DP ~ EE + CC + RC 
    EE ~ RC + CC + SE
    SE ~ DM + SS + PS
    ELC ~ SE + DM
    # latent variables
    RA =~ RA1 + RA2
    RC =~ RC1 + RC2 + WO1 + WO2
    CC =~ CC1 + CC2 + CC3 + CC4
    DM =~ DM1 + DM2
    SS =~ SS1 + SS2
    PS =~ PS1 + PS2
    SE =~ SE1 + SE2 + SE3
    ELC =~ ELC1 + ELC2 + ELC3 + ELC4 + ELC5
    EE =~ EE1 + EE2 + EE3
    DP =~ DP1 + DP2
    PA =~ PA1 + PA2 + PA3
"

Model2 <- 
"
    # regression
    PA ~ RA + DP + SE + EE
    DP ~ EE + CC
    EE ~ RC + CC + SE
    SE ~ DM + SS 
    ELC ~ SE + RC + PS
    # latent variables
    RA =~ RA1 + RA2
    RC =~ RC1 + RC2 + WO1 + WO2
    CC =~ CC1 + CC2 + CC3 + CC4
    DM =~ DM1 + DM2
    SS =~ SS1 + SS2
    PS =~ PS1 + PS2
    SE =~ SE1 + SE2 + SE3
    ELC =~ ELC1 + ELC2 + ELC3 + ELC4 + ELC5
    EE =~ EE1 + EE2 + EE3
    DP =~ DP1 + DP2
    PA =~ PA1 + PA2 + PA3
"

Model3 <- 
"
  # regression
    PA ~ RA + DP + SE
    DP ~ EE + CC + SE
    EE ~ RC + CC + SE
    SE ~ DM + SS 
    ELC ~ SE + RC + PS
  # latent variables
    RA =~ RA1 + RA2
    RC =~ RC1 + RC2 + WO1 + WO2
    CC =~ CC1 + CC2 + CC3 + CC4
    DM =~ DM1 + DM2
    SS =~ SS1 + SS2
    PS =~ PS1 + PS2
    SE =~ SE1 + SE2 + SE3
    ELC =~ ELC1 + ELC2 + ELC3 + ELC4 + ELC5
    EE =~ EE1 + EE2 + EE3
    DP =~ DP1 + DP2
    PA =~ PA1 + PA2 + PA3
  # covariance
    ELC ~~ 0*PA
"

## Fitting via lavaan
Model1_fit <- sem(Model1, data=burnout)
Model2_fit <- sem(Model2, data=burnout)
Model3_fit <- sem(Model3, data=burnout)

## Standardizing all parameters
standardizedSolution(Model1_fit)
standardizedSolution(Model2_fit)
standardizedSolution(Model3_fit)

```

 
## Part 2: Applying MVP test to 3 shared paths

```{r application_p2, echo=FALSE}

## Applying MVP test to three main path estimates
list <- list(Model1_fit, 
             Model2_fit, 
             Model3_fit)
## DP~EE
path1test <- mvpt(list, "DP~EE")$p.val
print(paste("1. Emotional exhaustion path to depersonalization (p-value):", round(path1test, 3))) 
## PA~DP
path2test <- mvpt(list, "PA~DP")$p.val
print(paste("2. Depersonalization path to personal accomplishment (p-value):", round(path2test, 3))) 
## PA~SE
path3test <- mvpt(list, "PA~SE")$p.val
print(paste("3. Self-esteem path to personal accomplishment (p-value):", round(path3test, 3))) 

```

